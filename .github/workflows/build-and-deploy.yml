name: Build and Deploy to ECS (Multi-Bootstrap)

on:
  push:
    branches:
      - main
    paths-ignore:
      - 'terraform/**'
      - '.github/workflows/terraform-*.yml'
      - '**.md'
      - 'docs/**'

permissions:
  contents: read
  id-token: write

env:
  AWS_REGION: ap-northeast-2
  ECR_REPOSITORY: fileflow
  ECS_CLUSTER: fileflow-prod

jobs:
  # ========================================
  # Step 1: ë³€ê²½ ê°ì§€ (ì–´ë–¤ Bootstrapì´ ë³€ê²½ë˜ì—ˆë‚˜?)
  # ========================================
  detect-changes:
    name: Detect Changed Bootstraps
    runs-on: ubuntu-latest
    outputs:
      web-api: ${{ steps.filter.outputs.web-api }}
      scheduler-download: ${{ steps.filter.outputs.scheduler-download }}
      scheduler-pipeline: ${{ steps.filter.outputs.scheduler-pipeline }}
      scheduler-upload: ${{ steps.filter.outputs.scheduler-upload }}
      any-changed: ${{ steps.filter.outputs.any-changed }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # ì´ì „ ì»¤ë°‹ê³¼ ë¹„êµ

      - name: Detect changed paths
        id: filter
        run: |
          # ë³€ê²½ëœ íŒŒì¼ ëª©ë¡
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)

          echo "ðŸ“ Changed files:"
          echo "$CHANGED_FILES"
          echo ""

          # Bootstrapë³„ ë³€ê²½ ì—¬ë¶€ ê°ì§€
          WEB_API=false
          DOWNLOAD=false
          PIPELINE=false
          UPLOAD=false

          # Web API ë³€ê²½ (REST API + ABAC)
          if echo "$CHANGED_FILES" | grep -qE '^(domain/|application/|adapter-in/rest-api/|adapter-out/(persistence-mysql|persistence-redis|abac-cel|aws-s3)/|bootstrap/bootstrap-web-api/)'; then
            WEB_API=true
          fi

          # Download Scheduler ë³€ê²½ (HTTP Client ì‚¬ìš©)
          if echo "$CHANGED_FILES" | grep -qE '^(domain/|application/|adapter-out/(persistence-mysql|persistence-redis|aws-s3|http-client)/|bootstrap/bootstrap-scheduler-download/)'; then
            DOWNLOAD=true
          fi

          # Pipeline Scheduler ë³€ê²½ (Image Processor, Metadata Extractor ì‚¬ìš©)
          if echo "$CHANGED_FILES" | grep -qE '^(domain/|application/|adapter-out/(persistence-mysql|persistence-redis|aws-s3|image-processor|metadata-extractor)/|bootstrap/bootstrap-scheduler-pipeline/)'; then
            PIPELINE=true
          fi

          # Upload Scheduler ë³€ê²½ (Scheduler Adapter ì‚¬ìš©)
          if echo "$CHANGED_FILES" | grep -qE '^(domain/|application/|adapter-in/scheduler/|adapter-out/(persistence-mysql|persistence-redis|aws-s3)/|bootstrap/bootstrap-scheduler-upload/)'; then
            UPLOAD=true
          fi

          # ì¶œë ¥
          echo "web-api=${WEB_API}" >> $GITHUB_OUTPUT
          echo "scheduler-download=${DOWNLOAD}" >> $GITHUB_OUTPUT
          echo "scheduler-pipeline=${PIPELINE}" >> $GITHUB_OUTPUT
          echo "scheduler-upload=${UPLOAD}" >> $GITHUB_OUTPUT

          # í•˜ë‚˜ë¼ë„ ë³€ê²½ë˜ì—ˆëŠ”ì§€
          ANY_CHANGED=false
          if [ "$WEB_API" = "true" ] || [ "$DOWNLOAD" = "true" ] || [ "$PIPELINE" = "true" ] || [ "$UPLOAD" = "true" ]; then
            ANY_CHANGED=true
          fi
          echo "any-changed=${ANY_CHANGED}" >> $GITHUB_OUTPUT

          echo "ðŸ” Detection Results:"
          echo "  - Web API: ${WEB_API}"
          echo "  - Download Scheduler: ${DOWNLOAD}"
          echo "  - Pipeline Scheduler: ${PIPELINE}"
          echo "  - Upload Scheduler: ${UPLOAD}"

  # ========================================
  # Step 2: í…ŒìŠ¤íŠ¸ ì‹¤í–‰ (ê³µí†µ)
  # ========================================
  test:
    name: Run Tests
    needs: detect-changes
    if: needs.detect-changes.outputs.any-changed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: 'gradle'

      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      - name: Run tests
        run: |
          echo "ðŸ§ª Running tests..."
          ./gradlew clean test -x jacocoTestCoverageVerification --no-daemon --stacktrace
          echo "âœ… Tests completed"

  # ========================================
  # Step 3: ë¹Œë“œ ë° í‘¸ì‹œ (Matrix ì „ëžµ)
  # ========================================
  build-and-push:
    name: Build ${{ matrix.bootstrap }}
    needs: [detect-changes, test]
    if: needs.detect-changes.outputs.any-changed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 30

    strategy:
      fail-fast: false
      matrix:
        include:
          - bootstrap: web-api
            port: 8080
            health-path: /actuator/health
            service: fileflow

          - bootstrap: scheduler-download
            port: 9091
            health-path: /actuator/health
            service: fileflow-scheduler-download

          - bootstrap: scheduler-pipeline
            port: 9092
            health-path: /actuator/health
            service: fileflow-scheduler-pipeline

          - bootstrap: scheduler-upload
            port: 9093
            health-path: /actuator/health
            service: fileflow-scheduler-upload

    # ì¡°ê±´: í•´ë‹¹ Bootstrapì´ ë³€ê²½ëœ ê²½ìš°ë§Œ ì‹¤í–‰
    if: |
      (matrix.bootstrap == 'web-api' && needs.detect-changes.outputs.web-api == 'true') ||
      (matrix.bootstrap == 'scheduler-download' && needs.detect-changes.outputs.scheduler-download == 'true') ||
      (matrix.bootstrap == 'scheduler-pipeline' && needs.detect-changes.outputs.scheduler-pipeline == 'true') ||
      (matrix.bootstrap == 'scheduler-upload' && needs.detect-changes.outputs.scheduler-upload == 'true')

    outputs:
      image-tag: ${{ steps.image-tag.outputs.tag }}
      image-uri: ${{ steps.build-image.outputs.image }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-duration-seconds: 3600
          role-session-name: GitHubActions-${{ matrix.bootstrap }}-Build

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Generate image tag
        id: image-tag
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          TAG="${{ matrix.bootstrap }}-${{ github.run_number }}-${SHORT_SHA}"
          echo "tag=${TAG}" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Image tag: ${TAG}"

      - name: Build and push Docker image
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.image-tag.outputs.tag }}
          BOOTSTRAP: ${{ matrix.bootstrap }}
          PORT: ${{ matrix.port }}
          HEALTH_PATH: ${{ matrix.health-path }}
        run: |
          echo "ðŸ³ Building Docker image for ${BOOTSTRAP}..."
          IMAGE_URI="${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"

          docker build \
            --build-arg BOOTSTRAP_NAME=${BOOTSTRAP} \
            --build-arg EXPOSE_PORT=${PORT} \
            --build-arg HEALTH_CHECK_PATH=${HEALTH_PATH} \
            -t ${IMAGE_URI} .

          # Latest íƒœê·¸ë„ ì¶”ê°€
          docker tag ${IMAGE_URI} ${ECR_REGISTRY}/${ECR_REPOSITORY}:${BOOTSTRAP}-latest

          echo "ðŸ“¤ Pushing to ECR..."
          docker push ${IMAGE_URI}
          docker push ${ECR_REGISTRY}/${ECR_REPOSITORY}:${BOOTSTRAP}-latest

          echo "image=${IMAGE_URI}" >> $GITHUB_OUTPUT
          echo "âœ… Image pushed: ${IMAGE_URI}"

      - name: Image vulnerability scan
        continue-on-error: true
        run: |
          echo "ðŸ” Checking ECR scan results..."
          aws ecr describe-image-scan-findings \
            --repository-name ${ECR_REPOSITORY} \
            --image-id imageTag=${{ steps.image-tag.outputs.tag }} \
            --region ${AWS_REGION} || echo "âš ï¸ Scan not yet complete"

  # ========================================
  # Step 4: ECS ë°°í¬ (ë³€ê²½ëœ Bootstrapë§Œ)
  # ========================================
  deploy-web-api:
    name: Deploy Web API
    needs: [detect-changes, build-and-push]
    if: needs.detect-changes.outputs.web-api == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-duration-seconds: 3600
          role-session-name: GitHubActions-WebAPI-Deploy

      - name: Update ECS service (Web API)
        run: |
          echo "ðŸš€ Deploying Web API..."

          # Task Definition ARN ê°€ì ¸ì˜¤ê¸°
          TASK_DEF_ARN=$(aws ecs describe-services \
            --cluster ${ECS_CLUSTER} \
            --services fileflow \
            --query 'services[0].taskDefinition' \
            --output text)

          # Task Definition ê°€ì ¸ì˜¤ê¸°
          aws ecs describe-task-definition \
            --task-definition ${TASK_DEF_ARN} \
            --query 'taskDefinition' > task-definition.json

          # ìƒˆ ì´ë¯¸ì§€ URIë¡œ ì—…ë°ì´íŠ¸
          IMAGE_URI="${{ needs.build-and-push.outputs.image-uri }}"
          cat task-definition.json | \
            jq --arg IMAGE "$IMAGE_URI" \
               '.containerDefinitions[0].image = $IMAGE' | \
            jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)' \
            > new-task-definition.json

          # ìƒˆ Task Definition ë“±ë¡
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://new-task-definition.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)

          # ECS ì„œë¹„ìŠ¤ ì—…ë°ì´íŠ¸
          aws ecs update-service \
            --cluster ${ECS_CLUSTER} \
            --service fileflow \
            --task-definition ${NEW_TASK_DEF_ARN} \
            --force-new-deployment \
            --no-cli-pager

          echo "â³ Waiting for service stability..."
          aws ecs wait services-stable \
            --cluster ${ECS_CLUSTER} \
            --services fileflow

          echo "âœ… Web API deployment completed"

  deploy-download-scheduler:
    name: Deploy Download Scheduler
    needs: [detect-changes, build-and-push]
    if: needs.detect-changes.outputs.scheduler-download == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-duration-seconds: 3600
          role-session-name: GitHubActions-DownloadScheduler-Deploy

      - name: Update ECS service (Download Scheduler)
        run: |
          echo "ðŸš€ Deploying Download Scheduler..."

          SERVICE_NAME="fileflow-scheduler-download"

          TASK_DEF_ARN=$(aws ecs describe-services \
            --cluster ${ECS_CLUSTER} \
            --services ${SERVICE_NAME} \
            --query 'services[0].taskDefinition' \
            --output text)

          aws ecs describe-task-definition \
            --task-definition ${TASK_DEF_ARN} \
            --query 'taskDefinition' > task-definition.json

          IMAGE_URI="${{ needs.build-and-push.outputs.image-uri }}"
          cat task-definition.json | \
            jq --arg IMAGE "$IMAGE_URI" \
               '.containerDefinitions[0].image = $IMAGE' | \
            jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)' \
            > new-task-definition.json

          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://new-task-definition.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)

          aws ecs update-service \
            --cluster ${ECS_CLUSTER} \
            --service ${SERVICE_NAME} \
            --task-definition ${NEW_TASK_DEF_ARN} \
            --force-new-deployment \
            --no-cli-pager

          echo "â³ Waiting for service stability..."
          aws ecs wait services-stable \
            --cluster ${ECS_CLUSTER} \
            --services ${SERVICE_NAME}

          echo "âœ… Download Scheduler deployment completed"

  deploy-pipeline-scheduler:
    name: Deploy Pipeline Scheduler
    needs: [detect-changes, build-and-push]
    if: needs.detect-changes.outputs.scheduler-pipeline == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-duration-seconds: 3600
          role-session-name: GitHubActions-PipelineScheduler-Deploy

      - name: Update ECS service (Pipeline Scheduler)
        run: |
          echo "ðŸš€ Deploying Pipeline Scheduler..."

          SERVICE_NAME="fileflow-scheduler-pipeline"

          TASK_DEF_ARN=$(aws ecs describe-services \
            --cluster ${ECS_CLUSTER} \
            --services ${SERVICE_NAME} \
            --query 'services[0].taskDefinition' \
            --output text)

          aws ecs describe-task-definition \
            --task-definition ${TASK_DEF_ARN} \
            --query 'taskDefinition' > task-definition.json

          IMAGE_URI="${{ needs.build-and-push.outputs.image-uri }}"
          cat task-definition.json | \
            jq --arg IMAGE "$IMAGE_URI" \
               '.containerDefinitions[0].image = $IMAGE' | \
            jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)' \
            > new-task-definition.json

          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://new-task-definition.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)

          aws ecs update-service \
            --cluster ${ECS_CLUSTER} \
            --service ${SERVICE_NAME} \
            --task-definition ${NEW_TASK_DEF_ARN} \
            --force-new-deployment \
            --no-cli-pager

          echo "â³ Waiting for service stability..."
          aws ecs wait services-stable \
            --cluster ${ECS_CLUSTER} \
            --services ${SERVICE_NAME}

          echo "âœ… Pipeline Scheduler deployment completed"

  deploy-upload-scheduler:
    name: Deploy Upload Scheduler
    needs: [detect-changes, build-and-push]
    if: needs.detect-changes.outputs.scheduler-upload == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-duration-seconds: 3600
          role-session-name: GitHubActions-UploadScheduler-Deploy

      - name: Update ECS service (Upload Scheduler)
        run: |
          echo "ðŸš€ Deploying Upload Scheduler..."

          SERVICE_NAME="fileflow-scheduler-upload"

          TASK_DEF_ARN=$(aws ecs describe-services \
            --cluster ${ECS_CLUSTER} \
            --services ${SERVICE_NAME} \
            --query 'services[0].taskDefinition' \
            --output text)

          aws ecs describe-task-definition \
            --task-definition ${TASK_DEF_ARN} \
            --query 'taskDefinition' > task-definition.json

          IMAGE_URI="${{ needs.build-and-push.outputs.image-uri }}"
          cat task-definition.json | \
            jq --arg IMAGE "$IMAGE_URI" \
               '.containerDefinitions[0].image = $IMAGE' | \
            jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)' \
            > new-task-definition.json

          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://new-task-definition.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)

          aws ecs update-service \
            --cluster ${ECS_CLUSTER} \
            --service ${SERVICE_NAME} \
            --task-definition ${NEW_TASK_DEF_ARN} \
            --force-new-deployment \
            --no-cli-pager

          echo "â³ Waiting for service stability..."
          aws ecs wait services-stable \
            --cluster ${ECS_CLUSTER} \
            --services ${SERVICE_NAME}

          echo "âœ… Upload Scheduler deployment completed"

  # ========================================
  # Step 5: ë°°í¬ ì™„ë£Œ ì•Œë¦¼
  # ========================================
  notify-completion:
    name: Notify Deployment Completion
    needs: [detect-changes, build-and-push, deploy-web-api, deploy-download-scheduler, deploy-pipeline-scheduler, deploy-upload-scheduler]
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Create Deployment Summary
        run: |
          echo "## ðŸš€ FileFlow Multi-Bootstrap Deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment**: Production" >> $GITHUB_STEP_SUMMARY
          echo "**Deployed by**: @${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“¦ Deployment Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Bootstrap | Changed | Build | Deploy |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|---------|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Web API | ${{ needs.detect-changes.outputs.web-api }} | ${{ needs.build-and-push.result }} | ${{ needs.deploy-web-api.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Download Scheduler | ${{ needs.detect-changes.outputs.scheduler-download }} | ${{ needs.build-and-push.result }} | ${{ needs.deploy-download-scheduler.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Pipeline Scheduler | ${{ needs.detect-changes.outputs.scheduler-pipeline }} | ${{ needs.build-and-push.result }} | ${{ needs.deploy-pipeline-scheduler.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Upload Scheduler | ${{ needs.detect-changes.outputs.scheduler-upload }} | ${{ needs.build-and-push.result }} | ${{ needs.deploy-upload-scheduler.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Next Steps**:" >> $GITHUB_STEP_SUMMARY
          echo "1. Check CloudWatch logs for application startup" >> $GITHUB_STEP_SUMMARY
          echo "2. Verify health checks" >> $GITHUB_STEP_SUMMARY
          echo "3. Monitor CloudWatch metrics" >> $GITHUB_STEP_SUMMARY
