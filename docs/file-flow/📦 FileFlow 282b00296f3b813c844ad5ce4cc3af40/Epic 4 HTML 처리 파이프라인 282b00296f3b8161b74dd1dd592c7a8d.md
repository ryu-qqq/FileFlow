# Epic 4: HTML 처리 파이프라인

## 🎯 개요

상품 상세 HTML을 자동으로 처리하여 이미지 최적화, 텍스트 추출, CDN 배포를 자동화합니다.

**목표**: 상품 상세 페이지 성능 개선 및 검색 정확도 향상

**예상 시간**: 40시간 (1주)

**우선순위**: P3

---

## 🔑 핵심 기능

### 1. HTML 파싱

- Jsoup 기반 HTML 파싱
- 이미지 태그 추출 (`<img>` 태그)
- 텍스트 추출 및 정제
- 메타데이터 추출

### 2. 외부 이미지 다운로드

- HTML 내 외부 이미지 URL 식별
- HTTP 기반 병렬 다운로드
- S3 업로드
- 재시도 로직 (최대 3회)

### 3. 이미지 최적화

- Epic 3 이미지 파이프라인 재사용
- WebP 변환
- 압축 (품질 90%)
- 썸네일 생성

### 4. HTML 재생성

- 이미지 URL을 S3 URL로 치환
- HTML 정제 (sanitization)
- 최적화된 HTML 생성

### 5. CDN 배포

- CloudFront 자동 배포
- 캐시 무효화

---

## 📊 처리 플로우

```
[원본 HTML 입력]
    ↓
[1. HTML 파싱]
    ├─ 이미지 URL 추출
    ├─ 텍스트 추출
    └─ 구조 분석
    ↓
[2. 외부 이미지 다운로드]
    ├─ URL별 병렬 다운로드
    ├─ S3 업로드
    └─ URL 매핑 생성
    ↓
[3. 이미지 최적화] (Epic 3 재사용)
    ├─ WebP 변환
    ├─ 압축
    ├─ 썸네일 생성
    └─ CDN URL 생성
    ↓
[4. HTML 재생성]
    ├─ 이미지 URL 치환
    ├─ HTML 정제
    └─ 최적화된 HTML 생성
    ↓
[5. CDN 배포]
    └─ CloudFront 배포
    ↓
[최적화된 HTML 완료]
```

---

## 🏗️ 아키텍처 설계

### Hexagonal Architecture 적용

```
┌─────────────────────────────────────────┐
│         Interface Layer                 │
│  ┌───────────────────────────────┐     │
│  │  HtmlProcessingController     │     │
│  │  - POST /api/v1/html/parse    │     │
│  │  - POST /api/v1/html/process  │     │
│  │  - GET /api/v1/html/{id}      │     │
│  └───────────────────────────────┘     │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│       Application Layer                 │
│  ┌───────────────────────────────┐     │
│  │  ParseHtmlUseCase             │     │
│  │  DownloadExternalImagesUseCase│     │
│  │  OptimizeHtmlImagesUseCase    │     │
│  │  GenerateOptimizedHtmlUseCase │     │
│  └───────────────────────────────┘     │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│          Domain Layer                   │
│  ┌───────────────────────────────┐     │
│  │  HtmlContent (Entity)         │     │
│  │  HtmlImage (Entity)           │     │
│  │  ProcessedHtml (Entity)       │     │
│  │                               │     │
│  │  HtmlParserPort               │     │
│  │  ImageDownloaderPort          │     │
│  │  HtmlGeneratorPort            │     │
│  │  HtmlStoragePort              │     │
│  └───────────────────────────────┘     │
└─────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────┐
│      Infrastructure Layer               │
│  ┌───────────────────────────────┐     │
│  │  JsoupHtmlParserAdapter       │     │
│  │  HttpImageDownloaderAdapter   │     │
│  │  S3HtmlStorageAdapter         │     │
│  │  MySQLHtmlRepository          │     │
│  └───────────────────────────────┘     │
└─────────────────────────────────────────┘
```

---

## 📦 Domain 모델

### 1. HtmlContent (Entity)

```java
public class HtmlContent {
    private final HtmlContentId id;
    private final String rawHtml;
    private final List<HtmlImage> images;
    private final String extractedText;
    private final ProcessingStatus status;
    private final Instant createdAt;
    
    public static HtmlContent create(
        String rawHtml,
        List<HtmlImage> images,
        String extractedText
    ) {
        return new HtmlContent(
            HtmlContentId.generate(),
            rawHtml,
            images,
            extractedText,
            ProcessingStatus.PENDING,
            [Instant.now](http://Instant.now)()
        );
    }
}
```

### 2. HtmlImage (Entity)

```java
public class HtmlImage {
    private final HtmlImageId id;
    private final String originalUrl;
    private final String optimizedUrl;
    private final ImageMetadata metadata;
    private final ProcessingStatus status;
    
    public static HtmlImage create(
        String originalUrl,
        String altText,
        String width,
        String height
    ) {
        return new HtmlImage(
            HtmlImageId.generate(),
            originalUrl,
            null,
            ImageMetadata.of(altText, width, height),
            ProcessingStatus.PENDING
        );
    }
}
```

### 3. ProcessedHtml (Entity)

```java
public class ProcessedHtml {
    private final ProcessedHtmlId id;
    private final HtmlContentId htmlContentId;
    private final String optimizedHtml;
    private final String cdnUrl;
    private final ProcessingMetadata metadata;
    private final Instant processedAt;
    
    public static ProcessedHtml create(
        HtmlContentId contentId,
        String optimizedHtml,
        HtmlMetrics metrics
    ) {
        return new ProcessedHtml(
            ProcessedHtmlId.generate(),
            contentId,
            optimizedHtml,
            null,
            ProcessingMetadata.of(metrics),
            [Instant.now](http://Instant.now)()
        );
    }
}
```

---

## 🔌 Port 인터페이스

### 1. HtmlParserPort

```java
public interface HtmlParserPort {
    ParsedHtml parse(String rawHtml);
    List<HtmlImage> extractImages(String html);
    String extractText(String html);
}
```

### 2. ImageDownloaderPort

```java
public interface ImageDownloaderPort {
    DownloadedImage download(String imageUrl);
    List<DownloadedImage> downloadBatch(List<String> imageUrls);
}
```

### 3. HtmlGeneratorPort

```java
public interface HtmlGeneratorPort {
    String replaceImageUrls(String html, Map<String, String> urlMapping);
    String sanitize(String html);
    String optimize(String html);
}
```

### 4. HtmlStoragePort

```java
public interface HtmlStoragePort {
    void save(HtmlContent content);
    Optional<HtmlContent> findById(HtmlContentId id);
    void saveProcessed(ProcessedHtml processed);
    Optional<ProcessedHtml> findProcessedById(ProcessedHtmlId id);
}
```

---

## 🎬 UseCase 구현

### 1. ParseHtmlUseCase

```java
public class ParseHtmlUseCase {
    private final HtmlParserPort htmlParser;
    private final HtmlStoragePort htmlStorage;
    
    public ParsedHtmlResult execute(ParseHtmlCommand command) {
        // 1. HTML 파싱
        ParsedHtml parsed = htmlParser.parse(command.rawHtml());
        
        // 2. 이미지 추출
        List<HtmlImage> images = htmlParser.extractImages(command.rawHtml());
        
        // 3. 텍스트 추출
        String text = htmlParser.extractText(command.rawHtml());
        
        // 4. HtmlContent 생성
        HtmlContent content = HtmlContent.create(
            command.rawHtml(),
            images,
            text
        );
        
        // 5. 저장
        [htmlStorage.save](http://htmlStorage.save)(content);
        
        return new ParsedHtmlResult(
            content.getId(),
            images.size(),
            text.length(),
            ProcessingStatus.COMPLETED
        );
    }
}
```

### 2. DownloadExternalImagesUseCase

```java
public class DownloadExternalImagesUseCase {
    private final ImageDownloaderPort downloader;
    private final FileUploadPort fileUpload;
    
    public DownloadedImagesResult execute(DownloadImagesCommand command) {
        Map<String, String> urlMapping = new HashMap<>();
        
        for (String url : command.imageUrls()) {
            try {
                // 1. 이미지 다운로드
                DownloadedImage image = [downloader.download](http://downloader.download)(url);
                
                // 2. S3 업로드
                String s3Url = fileUpload.upload(image);
                
                // 3. URL 매핑 저장
                urlMapping.put(url, s3Url);
                
            } catch (Exception e) {
                // 에러 처리
            }
        }
        
        return new DownloadedImagesResult(
            urlMapping,
            urlMapping.size(),
            0
        );
    }
}
```

### 3. OptimizeHtmlImagesUseCase

```java
public class OptimizeHtmlImagesUseCase {
    private final ImageProcessingPort imageProcessor;  // Epic 3
    
    public OptimizedImagesResult execute(OptimizeImagesCommand command) {
        // Epic 3 이미지 파이프라인 호출
        Map<String, OptimizedImageUrls> urlMapping = new HashMap<>();
        
        for (HtmlImage image : images) {
            OptimizedImage optimized = imageProcessor.process(
                image.getOptimizedUrl(),
                command.options()
            );
            
            urlMapping.put(
                image.getOriginalUrl(),
                new OptimizedImageUrls(
                    optimized.getOptimizedUrl(),
                    optimized.getThumbnailUrl(),
                    optimized.getCdnUrl()
                )
            );
        }
        
        return new OptimizedImagesResult(urlMapping, urlMapping.size(), 0);
    }
}
```

### 4. GenerateOptimizedHtmlUseCase

```java
public class GenerateOptimizedHtmlUseCase {
    private final HtmlGeneratorPort htmlGenerator;
    private final HtmlStoragePort htmlStorage;
    private final CdnPort cdnPort;
    
    public OptimizedHtmlResult execute(GenerateOptimizedHtmlCommand command) {
        // 1. 원본 HTML 로드
        HtmlContent content = htmlStorage.findById(command.contentId())
            .orElseThrow();
        
        // 2. 이미지 URL 치환
        String replacedHtml = htmlGenerator.replaceImageUrls(
            content.getRawHtml(),
            command.imageUrlMapping()
        );
        
        // 3. HTML 정제 및 최적화
        String optimized = htmlGenerator.optimize(
            htmlGenerator.sanitize(replacedHtml)
        );
        
        // 4. ProcessedHtml 생성 및 저장
        ProcessedHtml processed = ProcessedHtml.create(
            command.contentId(),
            optimized,
            calculateMetrics(content.getRawHtml(), optimized)
        );
        
        htmlStorage.saveProcessed(processed);
        
        // 5. CDN 배포
        String cdnUrl = cdnPort.deploy(processed);
        
        return new OptimizedHtmlResult(
            processed.getId(),
            optimized,
            cdnUrl,
            processed.getMetadata().getMetrics()
        );
    }
}
```

---

## 🔧 Adapter 구현

### 1. JsoupHtmlParserAdapter

```java
public class JsoupHtmlParserAdapter implements HtmlParserPort {
    
    @Override
    public ParsedHtml parse(String rawHtml) {
        Document doc = Jsoup.parse(rawHtml);
        return new ParsedHtml(
            doc.title(),
            doc.body().html(),
            extractMetadata(doc)
        );
    }
    
    @Override
    public List<HtmlImage> extractImages(String html) {
        Document doc = Jsoup.parse(html);
        Elements imgElements = [doc.select](http://doc.select)("img");
        
        return [imgElements.stream](http://imgElements.stream)()
            .map(this::convertToHtmlImage)
            .collect(Collectors.toList());
    }
    
    @Override
    public String extractText(String html) {
        Document doc = Jsoup.parse(html);
        return doc.body().text();
    }
}
```

### 2. HttpImageDownloaderAdapter

```java
public class HttpImageDownloaderAdapter implements ImageDownloaderPort {
    private final HttpClient httpClient;
    
    @Override
    public DownloadedImage download(String imageUrl) {
        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create(imageUrl))
            .timeout(Duration.ofSeconds(30))
            .GET()
            .build();
        
        HttpResponse<byte[]> response = httpClient.send(
            request,
            HttpResponse.BodyHandlers.ofByteArray()
        );
        
        return DownloadedImage.create(
            imageUrl,
            response.body(),
            extractContentType(response),
            response.body().length
        );
    }
    
    @Override
    public List<DownloadedImage> downloadBatch(List<String> imageUrls) {
        return imageUrls.parallelStream()
            .map(this::download)
            .collect(Collectors.toList());
    }
}
```

### 3. S3HtmlStorageAdapter

```java
public class S3HtmlStorageAdapter implements HtmlStoragePort {
    private final S3Client s3Client;
    private final String bucketName;
    
    @Override
    public void save(HtmlContent content) {
        String key = buildKey(content.getId());
        
        PutObjectRequest request = PutObjectRequest.builder()
            .bucket(bucketName)
            .key(key)
            .contentType("text/html; charset=UTF-8")
            .build();
        
        s3Client.putObject(
            request,
            RequestBody.fromString(content.getRawHtml())
        );
    }
    
    @Override
    public void saveProcessed(ProcessedHtml processed) {
        String key = buildProcessedKey(processed.getId());
        
        s3Client.putObject(
            PutObjectRequest.builder()
                .bucket(bucketName)
                .key(key)
                .contentType("text/html; charset=UTF-8")
                .build(),
            RequestBody.fromString(processed.getOptimizedHtml())
        );
    }
}
```

---

## 🗄️ 데이터베이스 스키마

### 1. html_content

```sql
CREATE TABLE html_content (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    content_id VARCHAR(36) NOT NULL UNIQUE,
    raw_html LONGTEXT NOT NULL,
    extracted_text TEXT,
    source_url VARCHAR(2048),
    status VARCHAR(20) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_content_id (content_id),
    INDEX idx_status (status),
    INDEX idx_created_at (created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

### 2. html_image

```sql
CREATE TABLE html_image (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    image_id VARCHAR(36) NOT NULL UNIQUE,
    content_id VARCHAR(36) NOT NULL,
    original_url VARCHAR(2048) NOT NULL,
    optimized_url VARCHAR(2048),
    cdn_url VARCHAR(2048),
    alt_text VARCHAR(255),
    width INT,
    height INT,
    status VARCHAR(20) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_image_id (image_id),
    INDEX idx_content_id (content_id),
    FOREIGN KEY (content_id) REFERENCES html_content(content_id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

### 3. processed_html

```sql
CREATE TABLE processed_html (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    processed_id VARCHAR(36) NOT NULL UNIQUE,
    content_id VARCHAR(36) NOT NULL,
    optimized_html LONGTEXT NOT NULL,
    cdn_url VARCHAR(2048),
    original_size INT NOT NULL,
    optimized_size INT NOT NULL,
    compression_ratio DECIMAL(5,2),
    image_count INT NOT NULL,
    processed_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_processed_id (processed_id),
    INDEX idx_content_id (content_id),
    FOREIGN KEY (content_id) REFERENCES html_content(content_id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

---

## 🌐 API 엔드포인트

### 1. HTML 파싱 API

```
POST /api/v1/html/parse
Content-Type: application/json

{
  "rawHtml": "<html>...</html>",
  "sourceUrl": "[https://example.com/product/123](https://example.com/product/123)"
}

Response:
{
  "contentId": "550e8400-e29b-41d4-a716-446655440000",
  "imageCount": 15,
  "textLength": 2048,
  "status": "COMPLETED"
}
```

### 2. HTML 전체 처리 API

```
POST /api/v1/html/process
Content-Type: application/json

{
  "rawHtml": "<html>...</html>",
  "sourceUrl": "[https://example.com/product/123](https://example.com/product/123)",
  "options": {
    "downloadExternalImages": true,
    "optimizeImages": true,
    "deployCdn": true
  }
}

Response:
{
  "processedId": "660f9511-f3ac-52e5-b827-557766551111",
  "cdnUrl": "[https://cdn.example.com/processed/660f9511.html](https://cdn.example.com/processed/660f9511.html)",
  "metrics": {
    "originalSize": 524288,
    "optimizedSize": 245760,
    "compressionRatio": 46.9,
    "imageCount": 15
  }
}
```

### 3. 처리 상태 조회 API

```
GET /api/v1/html/{contentId}/status

Response:
{
  "contentId": "550e8400-e29b-41d4-a716-446655440000",
  "status": "PROCESSING",
  "imageCount": 15,
  "progress": 60
}
```

### 4. 처리된 HTML 조회 API

```
GET /api/v1/html/processed/{processedId}

Response:
{
  "processedId": "660f9511-f3ac-52e5-b827-557766551111",
  "optimizedHtml": "<html>...</html>",
  "cdnUrl": "[https://cdn.example.com/processed/660f9511.html](https://cdn.example.com/processed/660f9511.html)",
  "metadata": {
    "originalSize": 524288,
    "optimizedSize": 245760,
    "processedAt": "2025-10-04T14:30:00Z"
  }
}
```

---

## 📁 S3 저장소 구조

```
s3://fileflow-prod/
└── b2c/
    └── product/
        └── {userId}/
            └── {productId}/
                └── html/
                    ├── original/
                    │   └── detail.html
                    ├── processed/
                    │   └── detail_optimized.html
                    └── images/
                        ├── original/
                        │   ├── extracted_1.jpg
                        │   └── extracted_2.jpg
                        └── optimized/
                            ├── extracted_1.webp
                            └── extracted_2.webp
```

---

## ✅ 작업 분해 (Tasks)

### KAN-52: HTML 처리 Domain 모델 구현 (4시간)

- HtmlContent, HtmlImage, ProcessedHtml 엔티티
- Value Objects (HtmlContentId, ImageMetadata 등)
- ProcessingStatus Enum

### KAN-53: HTML 처리 Port 인터페이스 정의 (3시간)

- HtmlParserPort
- ImageDownloaderPort
- HtmlGeneratorPort
- HtmlStoragePort
- HtmlImageStoragePort

### KAN-54: HTML 파싱 UseCase 구현 (5시간)

- ParseHtmlUseCase
- HTML 파싱 및 이미지 추출
- 텍스트 추출

### KAN-55: 외부 이미지 다운로드 UseCase 구현 (6시간)

- DownloadExternalImagesUseCase
- 병렬 다운로드
- 재시도 로직

### KAN-56: HTML 이미지 최적화 UseCase 구현 (5시간)

- OptimizeHtmlImagesUseCase
- Epic 3 파이프라인 연동

### KAN-57: 최적화된 HTML 생성 UseCase 구현 (6시간)

- GenerateOptimizedHtmlUseCase
- URL 치환
- HTML 정제 및 최적화

### KAN-58: Jsoup HTML 파서 Adapter 구현 (4시간)

- JsoupHtmlParserAdapter
- HTML 파싱
- 이미지 추출

### KAN-59: HTTP 이미지 다운로더 Adapter 구현 (5시간)

- HttpImageDownloaderAdapter
- 병렬 다운로드
- 타임아웃 처리

### KAN-60: S3 HTML 저장소 Adapter 구현 (4시간)

- S3HtmlStorageAdapter
- HTML 저장/조회

### KAN-61: 데이터베이스 스키마 설계 및 구현 (5시간)

- html_content 테이블
- html_image 테이블
- processed_html 테이블

### KAN-62: HTML 처리 API Controller 구현 (5시간)

- REST API 엔드포인트
- Request/Response DTO
- 입력 검증

### KAN-63: 통합 테스트 및 문서화 (6시간)

- End-to-End 테스트
- API 문서화
- README 업데이트

---

## 🔗 관련 링크

- **Jira Epic**: [KAN-51](https://ryuqqq.atlassian.net/browse/KAN-51)
- **GitHub**: [https://github.com/ryu-qqq/FileFlow](https://github.com/ryu-qqq/FileFlow)
- **Epic 3 (이미지 처리)**: 이미지 최적화 파이프라인 재사용
- **상위 프로젝트**: 🏗️ Setof 고도화 프로젝트

---

## 💡 기술적 고려사항

### 1. HTML 파싱

- Jsoup 사용 (안정성, 성능)
- 잘못된 HTML 처리 (자동 복구)
- XSS 방지 (sanitization)

### 2. 이미지 다운로드

- 병렬 처리 (최대 10개 동시)
- 타임아웃 설정 (30초)
- 재시도 로직 (최대 3회)
- 실패한 이미지는 건너뛰기 옵션

### 3. Epic 3 연동

- ImageProcessingPort 인터페이스 재사용
- 동일한 최적화 파이프라인 적용
- 일관된 이미지 품질 유지

### 4. 성능 최적화

- 병렬 이미지 다운로드
- S3 멀티파트 업로드
- CloudFront 캐싱

### 5. 에러 처리

- 단계별 에러 핸들링
- 부분 실패 허용
- 상세한 에러 로그

---

## 🎯 완료 기준

- [ ]  모든 Domain 모델 구현 완료
- [ ]  모든 Port 인터페이스 정의 완료
- [ ]  모든 UseCase 구현 완료
- [ ]  모든 Adapter 구현 완료
- [ ]  데이터베이스 스키마 구현 완료
- [ ]  API Controller 구현 완료
- [ ]  단위 테스트 작성 완료
- [ ]  통합 테스트 작성 완료
- [ ]  API 문서화 완료
- [ ]  Epic 3 연동 테스트 완료

---

## 📊 예상 결과

### 성능 개선

- HTML 크기 감소: 평균 50%
- 이미지 최적화: WebP 변환으로 70% 크기 감소
- 페이지 로딩 속도: 2~3배 개선

### 검색 정확도 향상

- 텍스트 추출로 상품 정보 검색 가능
- 메타데이터 자동 생성

### 운영 효율성

- 자동화된 처리 파이프라인
- 일관된 품질 유지
- 수작업 제거