package {{BASE_PACKAGE}}.bootstrap.architecture;

import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import com.tngtech.archunit.core.domain.JavaCall;
import com.tngtech.archunit.core.domain.JavaClasses;
import com.tngtech.archunit.core.domain.JavaMethod;
import com.tngtech.archunit.core.importer.ClassFileImporter;
import com.tngtech.archunit.core.importer.ImportOption;
import com.tngtech.archunit.lang.ArchCondition;
import com.tngtech.archunit.lang.ArchRule;
import com.tngtech.archunit.lang.ConditionEvents;
import com.tngtech.archunit.lang.SimpleConditionEvent;

import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.methods;
import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.noClasses;

/**
 * Zero-Tolerance 규칙 통합 ArchUnit 테스트
 *
 * <p>프로젝트의 핵심 Zero-Tolerance 규칙을 단일 테스트 클래스에서 검증합니다.</p>
 *
 * <h3>검증 규칙</h3>
 * <ul>
 *   <li>Lombok 금지 (Domain, Application, Persistence)</li>
 *   <li>Transaction Boundary (@Transactional 내 외부 API 호출 금지)</li>
 *   <li>Spring 프록시 제약 (private/final 메서드 @Transactional 금지)</li>
 *   <li>Long FK 전략 (JPA 관계 어노테이션 금지)</li>
 *   <li>Law of Demeter (Getter 체이닝 금지 - 가이드라인)</li>
 *   <li>Orchestration Pattern 규칙</li>
 * </ul>
 *
 * <p><strong>Note:</strong> 이 테스트는 기존 Layer별 ArchUnit 테스트를 보완하며,
 * Git pre-commit hooks의 13개 validator 스크립트를 대체합니다.</p>
 *
 * @author Claude Code
 * @since 2025-11-04
 */
@DisplayName("Zero-Tolerance 규칙 통합 검증")
class ZeroToleranceArchitectureTest {

    private static JavaClasses allClasses;

    @BeforeAll
    static void setUp() {
        allClasses = new ClassFileImporter()
            .withImportOption(ImportOption.Predefined.DO_NOT_INCLUDE_TESTS)
            .importPackages("{{BASE_PACKAGE}}");
    }

    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // 1️⃣ Lombok 금지 (Zero-Tolerance)
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

    @Nested
    @DisplayName("Lombok 금지 규칙")
    class LombokProhibitionTest {

        @Test
        @DisplayName("전체 프로젝트에서 Lombok @Data 금지")
        void shouldNotUseLombokData() {
            ArchRule rule = noClasses()
                .that().resideInAPackage("{{BASE_PACKAGE}}..")
                .should().beAnnotatedWith("lombok.Data")
                .because("Lombok @Data는 프로젝트 전체에서 금지됩니다 (Pure Java 사용)");

            rule.check(allClasses);
        }

        @Test
        @DisplayName("전체 프로젝트에서 Lombok @Builder 금지")
        void shouldNotUseLombokBuilder() {
            ArchRule rule = noClasses()
                .that().resideInAPackage("{{BASE_PACKAGE}}..")
                .should().beAnnotatedWith("lombok.Builder")
                .because("Lombok @Builder는 프로젝트 전체에서 금지됩니다 (Pure Java 사용)");

            rule.check(allClasses);
        }

        @Test
        @DisplayName("Domain Layer에서 Lombok @Getter/@Setter 금지")
        void domainLayerShouldNotUseLombokGetterSetter() {
            ArchRule rule = noClasses()
                .that().resideInAPackage("..domain..")
                .should().beAnnotatedWith("lombok.Getter")
                .orShould().beAnnotatedWith("lombok.Setter")
                .because("Domain Layer는 Pure Java를 사용해야 합니다");

            rule.check(allClasses);
        }
    }

    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // 2️⃣ Transaction Boundary (Zero-Tolerance)
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

    @Nested
    @DisplayName("Transaction Boundary 규칙")
    class TransactionBoundaryTest {

        @Test
        @DisplayName("@Transactional 메서드는 외부 API 호출을 하지 않아야 함")
        void transactionalMethodsShouldNotCallExternalAPIs() {
            ArchCondition<JavaMethod> notCallExternalAPI = new ArchCondition<JavaMethod>("not call external APIs") {
                @Override
                public void check(JavaMethod method, ConditionEvents events) {
                    method.getCallsFromSelf()
                        .stream()
                        .filter(ZeroToleranceArchitectureTest::isExternalAPICall)
                        .forEach(call -> {
                            String message = String.format(
                                "@Transactional 메서드 %s에서 외부 API %s를 호출합니다. " +
                                "트랜잭션은 짧게 유지하고, 외부 API 호출은 트랜잭션 밖에서 수행하세요.",
                                method.getFullName(),
                                call.getTarget().getFullName()
                            );
                            events.add(SimpleConditionEvent.violated(call, message));
                        });
                }
            };

            ArchRule rule = methods()
                .that().areAnnotatedWith("org.springframework.transaction.annotation.Transactional")
                .should(notCallExternalAPI)
                .because("@Transactional 메서드 내에서 외부 API 호출은 금지됩니다 (Transaction은 짧게 유지)");

            rule.check(allClasses);
        }

        @Test
        @DisplayName("@Transactional은 public 메서드에만 사용 가능")
        void transactionalShouldOnlyBeUsedOnPublicMethods() {
            ArchRule rule = methods()
                .that().areAnnotatedWith("org.springframework.transaction.annotation.Transactional")
                .should().bePublic()
                .because("Spring AOP는 public 메서드에서만 작동합니다. Private 메서드에 @Transactional은 작동하지 않습니다.");

            rule.check(allClasses);
        }

        @Test
        @DisplayName("@Transactional 메서드는 final 금지")
        void transactionalMethodsShouldNotBeFinal() {
            ArchRule rule = methods()
                .that().areAnnotatedWith("org.springframework.transaction.annotation.Transactional")
                .should().notBeFinal()
                .because("Spring AOP는 final 메서드를 프록시할 수 없습니다");

            rule.check(allClasses);
        }
    }

    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // 3️⃣ Law of Demeter (가이드라인)
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

    @Nested
    @DisplayName("Law of Demeter 규칙 (가이드라인)")
    class LawOfDemeterTest {

        // Note: Law of Demeter (Getter 체이닝 금지)는 ArchUnit으로 완벽하게 검증하기 어렵습니다.
        // 메서드 체인 호출 패턴을 감지하려면 바이트코드 분석이 필요하며,
        // 이는 ArchUnit의 범위를 벗어납니다.
        //
        // 대안:
        // 1. Checkstyle/PMD Custom Rules
        // 2. IntelliJ IDEA Structural Search
        // 3. 수동 코드 리뷰
        //
        // 가이드라인:
        // ❌ Bad: order.getCustomer().getAddress().getZip()
        // ✅ Good: order.getCustomerZipCode()
        //
        // ❌ Bad: setting.getId().value()
        // ✅ Good: setting.getIdValue()
        //
        // 검증 방법:
        // grep -r "\.get.*()\.get" domain/src/main/java
        // grep -r "\.get.*()\.get" application/src/main/java
    }

    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // 4️⃣ Orchestration Pattern (Zero-Tolerance)
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

    @Nested
    @DisplayName("Orchestration Pattern 규칙")
    class OrchestrationPatternTest {

        @Test
        @DisplayName("executeInternal()은 @Async 필수, @Transactional 금지")
        void executeInternalShouldHaveAsyncNotTransactional() {
            ArchRule asyncRule = methods()
                .that().haveName("executeInternal")
                .and().areProtected()
                .should().beAnnotatedWith("org.springframework.scheduling.annotation.Async")
                .because("executeInternal()은 외부 API 호출을 위해 @Async가 필수입니다");

            ArchRule transactionalRule = methods()
                .that().haveName("executeInternal")
                .should().notBeAnnotatedWith("org.springframework.transaction.annotation.Transactional")
                .because("executeInternal()은 외부 API 호출이므로 @Transactional을 사용하면 안 됩니다");

            asyncRule.check(allClasses);
            transactionalRule.check(allClasses);
        }

        @Test
        @DisplayName("Command는 Record 타입이어야 함 (Lombok 금지)")
        void commandsShouldBeRecords() {
            ArchRule rule = methods()
                .that().haveName("executeInternal")
                .and().areProtected()
                .should().haveRawReturnType(new com.tngtech.archunit.base.DescribedPredicate<com.tngtech.archunit.core.domain.JavaClass>("Outcome") {
                    @Override
                    public boolean test(com.tngtech.archunit.core.domain.JavaClass javaClass) {
                        return javaClass.getSimpleName().equals("Outcome") ||
                               javaClass.isAssignableTo("{{BASE_PACKAGE}}.application.common.orchestration.Outcome");
                    }
                })
                .because("executeInternal()은 Outcome (Ok/Retry/Fail)을 반환해야 타입 안전합니다");

            rule.check(allClasses);
        }
    }

    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // Helper Methods
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

    /**
     * 외부 API 호출인지 검증하는 헬퍼 메서드
     *
     * <p>다음 패턴을 외부 API 호출로 간주합니다:</p>
     * <ul>
     *   <li>RestTemplate (getForObject, postForObject, exchange 등)</li>
     *   <li>WebClient (get, post, retrieve 등)</li>
     *   <li>FeignClient 인터페이스 메서드</li>
     *   <li>HttpClient (send, execute 등)</li>
     *   <li>외부 Port (Out Port with Http/Rest/Api 키워드)</li>
     * </ul>
     *
     * @param call 메서드 호출
     * @return 외부 API 호출이면 true
     */
    private static boolean isExternalAPICall(JavaCall<?> call) {
        String targetClass = call.getTargetOwner().getName();
        String methodName = call.getTarget().getName();

        // RestTemplate
        if (targetClass.contains("RestTemplate")) {
            return true;
        }

        // WebClient
        if (targetClass.contains("WebClient")) {
            return true;
        }

        // FeignClient
        if (call.getTargetOwner().isAnnotatedWith("org.springframework.cloud.openfeign.FeignClient")) {
            return true;
        }

        // HttpClient
        if (targetClass.contains("HttpClient") || targetClass.contains("CloseableHttpClient")) {
            return true;
        }

        // Custom External Port (Out Port with Http/Rest/Api keywords)
        if (targetClass.contains(".port.out.") &&
            (targetClass.contains("Http") || targetClass.contains("Rest") || targetClass.contains("Api"))) {
            return true;
        }

        return false;
    }
}
